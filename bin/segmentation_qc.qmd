---
title: "Segmentation QC"
format: 
    html:
        embed-resources: true
lightbox: true
execute: 
  echo: false
  warning: false
  message: false
params:
    masks: ""
    images: ""
---

```{r setup_r}
library(dplyr)
library(ggplot2)
library(readr)
Sys.unsetenv("RETICULATE_PYTHON")
library(reticulate)
use_virtualenv("/mnt/scratch/projects/biol-imaging-2024/venv")
```

```{python setup_python}
import re
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap
import os
import math
from PIL import Image
```

```{python load_images}
# Identify which frames to plot
mask_fns = sorted(r.params['masks'].split(" "))
image_fns = sorted(r.params['images'].split(" "))
mask_fns_plot = [mask_fns[i] for i in range(len(mask_fns)) if i % 10 == 0]
image_fns_plot = [image_fns[i] for i in range(len(image_fns)) if i % 10 == 0]

def extract_frame_id(fn):
    bn = os.path.basename(fn)
    res = re.search('frame_([0-9]+)(_mask)?.png', bn)
    return int(res.groups()[0])

def get_image(fn):
    return np.array(Image.open(fn))

masks = [get_image(fn) for fn in mask_fns_plot]
images = [get_image(fn) for fn in image_fns_plot]
```

```{python plot_funcs}
# Create plots
def create_cmap(img, page_size=20, palette="Pastel1"):
    n_groups = np.unique(img).size
    
    viridis = plt.get_cmap(palette, page_size)
    newcolors = np.zeros((n_groups, 4))
    # Pagination
    n_remaining = n_groups
    start = 0
    while n_remaining > 0:
        n_page = min(n_remaining, page_size)
        newcolors[start:(start+n_page), ] = viridis.colors[:n_page]
        n_remaining -= n_page
        start += n_page
        
    # Shuffle
    rng = np.random.default_rng()
    rng.shuffle(newcolors)
    newcolors[0, ] = np.array([1, 1, 1, 0.1])
    return ListedColormap(newcolors)
```

@fig-segmentation shows a stitched plot of the identified segmentation masks from every 10th frame.

```{python fig-segmentation, fig.cap="Segmentation masks for every 10th frame"}
n_images = len(masks)
COLS = 8
ROWS = math.ceil(n_images / COLS)
fig, axes = plt.subplots(
    ROWS,
    COLS,
    sharex=True,
    sharey=True,
    figsize=(COLS*2, ROWS*2)
)
counter = 0
# Subplots returns 1D list if request 1 row, force
# it to always return 2D
if ROWS == 1:
    axes = [axes,]
for i, ax_row in enumerate(axes):
    for j in range(len(ax_row)):
        ax = ax_row[j]
        ax.tick_params(
            axis='both',
            which='both',
            bottom=False,
            left=False,
            labelbottom=False,
            labelleft=False
        )
        if counter >= len(masks):
            _dummy = ax.axis("off")
        else:
            _dummy = ax.imshow(
                images[counter],
                cmap="gray"
            )
            _dummy = ax.imshow(
                masks[counter],
                cmap=create_cmap(masks[counter]),
                alpha=0.4
            )
            _dummy = ax.set_title(
                f"Frame {extract_frame_id(mask_fns_plot[counter])}",
                fontsize=8
            )
        counter += 1
fig.subplots_adjust(wspace=0.05, hspace=0, top=0.99, left=0.01, bottom=0.01, right=0.99)
```

```{python load_counts}
# Summary statistics
def get_counts(fn):
    img = get_image(fn)
    counts = np.unique(img, return_counts=True)
    df = pd.DataFrame({
        'frame_id': extract_frame_id(fn),
        'mask_id': counts[0],
        'n': counts[1]
    })
    return df.loc[df['mask_id'] != 0]
    
counts = pd.concat([get_counts(x) for x in mask_fns])
```

@fig-cells-frame shows the distribution of the number of cells per frame.

```{r import_counts}
counts <- as_tibble(py$counts)
```

```{r fig-cells-frame, fig.cap="Histogram of the number of cells in a frame"}
df_cells <- counts |>
    count(frame_id)
cell_stats <- df_cells |>
    summarise(
        min = min(n),
        median = median(n),
        max = max(n),
        n = n()
    ) |>
    ungroup() |>
    mutate(label = sprintf("# frames: %d\nMin # cells: %d\nMedian # cells: %0.f\nMax # cells: %d",
                           n, min, median, max))
        
df_cells |>
    ggplot(aes(x=n)) +
        geom_histogram(colour="black", fill="white") +
        geom_label(aes(x=max, y=Inf, label=label), data=cell_stats,
                   hjust=1, vjust=1) +
        theme_bw() +
        labs(x="Number of cells in a frame", y="Number of frames")
```

@fig-cells-areas shows the distribution of cell areas.

```{r fig-cells-areas, fig.cap="Histogram of cell areas"}
area_stats <- counts |>
    summarise(
        min = min(n),
        median = median(n),
        max = max(n),
        n = n()
    ) |>
    ungroup() |>
    mutate(label = sprintf("# cells: %d\nMin area: %d\nMedian area: %.0f\nMax area: %d",
                           n, min, median, max))
        
counts |>
    ggplot(aes(x=n)) +
        geom_histogram(colour="black", fill="white") +
        geom_label(aes(x=max, y=Inf, label=label), data=area_stats,
                   hjust=1, vjust=1) +
        theme_bw() +
        labs(x="Cell size (pixels)", y="Number of cells")
```
